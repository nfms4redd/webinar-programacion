{
    "docs": [
        {
            "location": "/", 
            "text": "Curso de programaci\u00f3n de NFMS4REDD\n\n\nEl software utilizado para la diseminaci\u00f3n de datos es un portal web, que hace uso de la \narquitectura cliente-servidor\n.\n\n\nEn este curso se aprender\u00e1n a desarrollar nuevas funcionalidades para el portal. Se abordar\u00e1n las dos facetas de la arquitectura por separado: por un lado la parte cliente, y por otro lado la parte servidor.\n\n\n\u00cdndice\n\n\n\n\nPreparaci\u00f3n\n\n\n\n\nCliente\n\n\n\n\nHola mundo\n\n\nA\u00f1adir elementos a la interfaz\n\n\nReutilizar funcionalidad\n\n\nManejar eventos\n\n\nA\u00f1adir funcionalidad al mapa\n.\n\n\n\n\n\n\n\n\nServidor\n\n\n\n\nHola mundo\n\n\nServlet de configuraci\u00f3n\n\n\nServlet de acceso a base de datos\n\n\nConsideraciones sobre el despliegue\n\n\n\n\n\n\n\n\nEjercicios", 
            "title": "\u00cdndice"
        }, 
        {
            "location": "/#curso-de-programacion-de-nfms4redd", 
            "text": "El software utilizado para la diseminaci\u00f3n de datos es un portal web, que hace uso de la  arquitectura cliente-servidor .  En este curso se aprender\u00e1n a desarrollar nuevas funcionalidades para el portal. Se abordar\u00e1n las dos facetas de la arquitectura por separado: por un lado la parte cliente, y por otro lado la parte servidor.", 
            "title": "Curso de programaci\u00f3n de NFMS4REDD"
        }, 
        {
            "location": "/#indice", 
            "text": "Preparaci\u00f3n   Cliente   Hola mundo  A\u00f1adir elementos a la interfaz  Reutilizar funcionalidad  Manejar eventos  A\u00f1adir funcionalidad al mapa .     Servidor   Hola mundo  Servlet de configuraci\u00f3n  Servlet de acceso a base de datos  Consideraciones sobre el despliegue     Ejercicios", 
            "title": "\u00cdndice"
        }, 
        {
            "location": "/setup/", 
            "text": "Para este curso haremos uso de \nDocker\n. Docker es una herramienta que nos va a permitir la instalaci\u00f3n completa de todos los componentes del sistema de NFMS (PostGIS, GeoServer, portal) en unos pocos minutos y con muy pocos comandos.\n\n\nInstalar Docker\n\n\nLa instalaci\u00f3n de Docker es diferente en funci\u00f3n del sistema operativo. Aqu\u00ed se muestra el resumen de las posibilidades m\u00e1s comunes.\n\n\nSi el sistema operativo no se encuentra entre los siguientes, habr\u00e1 que dirigirse a la \ndocumentaci\u00f3n\n de Docker.\n\n\nEn caso de ser incapaz de instalar Docker de manera nativa en nuestro sistema, siempre se puede crear una m\u00e1quina virtual Ubuntu con VirtualBox (a partir de \nim\u00e1genes predefinidas\n, por ejemplo) e instalar Docker en la m\u00e1quina virtual.\n\n\nUbuntu 16.04 (o posterior)\n\n\nSe pueden encontrar unas instrucciones m\u00e1s detalladas en la instalaci\u00f3n en su \nweb\n. B\u00e1sicamente consiste en:\n\n\n# Instalar dependencias\n\napt-get update\napt-get install apt-transport-https ca-certificates curl software-properties-common\n\n# A\u00f1adir la clave GPG\n\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg \n|\n sudo apt-key add -\n\n# A\u00f1adir el repositorio apt\n\nsudo add-apt-repository \ndeb [arch=amd64] https://download.docker.com/linux/ubuntu \n$(\nlsb_release -cs\n)\n stable\n\n\n# Instalar\n\napt-get update\napt-get install docker-ce\n\n\n\n\n\nWindows 10\n\n\nSe pueden encontrar unas instrucciones m\u00e1s detalladas en la instalaci\u00f3n en su \nweb\n. B\u00e1sicamente consiste en:\n\n\n\n\nDescargar el \ninstalador\n y ejecutarlo.\n\n\nArrancar \nDocker for Windows\n.\n\n\nUna vez se ha terminado la inicializaci\u00f3n se abrir\u00e1 una consola con el s\u00edmbolo \n$\n. Basta con ejecutar \ndocker run hello-world\n para comprobar que la instalaci\u00f3n ha sido satisfactoria.\n\n\n\n\nWindows 7\n\n\nLa \u00faltima versi\u00f3n de Docker para Windows solo est\u00e1 disponible a partir de Windows 10. Para utilizar Docker en versiones anteriores de Windows habr\u00e1 que usar \nDocker Toolbox\n. B\u00e1sicamente consiste en:\n\n\n\n\nDescargar el \ninstalador\n y ejecutarlo.\n\n\nAbrir \nDocker Quickstart\n (por defecto se instala un icono en el escritorio). La primera vez que se abra necesitar\u00e1 ejecutar unos cuantos pasos de configuraci\u00f3n inicial que pueden tomar un tiempo y que requieren permisos especiales que habr\u00e1 que aceptar.\n\n\nUna vez se ha terminado la inicializaci\u00f3n se abrir\u00e1 una consola con el s\u00edmbolo \n$\n. Basta con ejecutar \ndocker run hello-world\n para comprobar que la instalaci\u00f3n ha sido satisfactoria.\n\n\n\n\nInstalar \ndocker-compose\n\n\ndocker-compose\n es una herramienta de Docker que nos permite ejecutar, enlazar y en general gestionar varios contenedores de manera conjunta y sencilla.\n\n\nLinux\n\n\nLa instalaci\u00f3n en Linux es muy sencilla. Basta con descargarlo y darle permisos de ejecuci\u00f3n:\n\n\ncurl -L https://github.com/docker/compose/releases/download/1.18.0/docker-compose-\n`\nuname -s\n`\n-\n`\nuname -m\n`\n -o /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n\n\n\n\n\nWindows\n\n\nEn Windows, \ndocker-compose\n viene instalado tanto con \nDocker for Windows\n como con \nDocker Toolbox\n, por lo que no ser\u00e1 necesario realizar nada m\u00e1s.\n\n\nOtros sistemas operativos\n\n\nSi el sistema operativo no se encuentra entre los anteriores, habr\u00e1 que dirigirse a la \ndocumentaci\u00f3n\n de Docker.\n\n\nArrancar el sistema\n\n\nEn primer lugar deberemos crear nuestro directorio de trabajo, que incluye subdirectorios para GeoServer y el portal. Por ejemplo:\n\n\ncd\n\nmkdir nfms\nmkdir nfms/geoserver\nmkdir nfms/geoladris\n\n\n\n\n\n\n\nNOTA\n: A lo largo de esta documentaci\u00f3n se incluir\u00e1n \u00fanicamente los comandos \nmkdir\n de Linux, asumiendo que en Windows se crean mediante el explorador de archivos.\n\n\n\n\nDespu\u00e9s, habr\u00e1 que descargarse los siguientes ficheros y copiarlos en el directorio de trabajo:\n\n\n\n\ndocker-compose.yml\n\n\ncontext.xml\n\n\nportal.zip\n\n\ndemo.war\n\n\n\n\nTras la descarga, habr\u00e1 que descomprimir el fichero \ndemo-*.war\n (realmente es un fichero \n.zip\n con la extensi\u00f3n cambiada) en un directorio \nportal\n y descomprimir el fichero \nportal.zip\n dentro del directorio de configuraci\u00f3n \ngeoladris\n. El resultado deber\u00eda ser el siguiente:\n\n\n\n\nFinalmente, bastar\u00e1 con arrancar el sistema con \ndocker-compose\n:\n\n\ncd\n ~/nfms\ndocker-compose up -d\n\n\n\n\n\nO, en Windows, arrancando \nDocker for Windows/Docker Toolbox\n:\n\n\ncd\n \ndirectorio\n\ndocker-compose up -d\n\n\n\n\n\nPara comprobar que la instalaci\u00f3n y el arranque se han completado con \u00e9xito podemos acceder al portal en \nhttp://localhost:8082/portal\n y a GeoServer en \nhttp://localhost:8081/geoserver\n.", 
            "title": "Preparaci\u00f3n"
        }, 
        {
            "location": "/setup/#instalar-docker", 
            "text": "La instalaci\u00f3n de Docker es diferente en funci\u00f3n del sistema operativo. Aqu\u00ed se muestra el resumen de las posibilidades m\u00e1s comunes.  Si el sistema operativo no se encuentra entre los siguientes, habr\u00e1 que dirigirse a la  documentaci\u00f3n  de Docker.  En caso de ser incapaz de instalar Docker de manera nativa en nuestro sistema, siempre se puede crear una m\u00e1quina virtual Ubuntu con VirtualBox (a partir de  im\u00e1genes predefinidas , por ejemplo) e instalar Docker en la m\u00e1quina virtual.", 
            "title": "Instalar Docker"
        }, 
        {
            "location": "/setup/#ubuntu-1604-o-posterior", 
            "text": "Se pueden encontrar unas instrucciones m\u00e1s detalladas en la instalaci\u00f3n en su  web . B\u00e1sicamente consiste en:  # Instalar dependencias \napt-get update\napt-get install apt-transport-https ca-certificates curl software-properties-common # A\u00f1adir la clave GPG \ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg  |  sudo apt-key add - # A\u00f1adir el repositorio apt \nsudo add-apt-repository  deb [arch=amd64] https://download.docker.com/linux/ubuntu  $( lsb_release -cs )  stable  # Instalar \napt-get update\napt-get install docker-ce", 
            "title": "Ubuntu 16.04 (o posterior)"
        }, 
        {
            "location": "/setup/#windows-10", 
            "text": "Se pueden encontrar unas instrucciones m\u00e1s detalladas en la instalaci\u00f3n en su  web . B\u00e1sicamente consiste en:   Descargar el  instalador  y ejecutarlo.  Arrancar  Docker for Windows .  Una vez se ha terminado la inicializaci\u00f3n se abrir\u00e1 una consola con el s\u00edmbolo  $ . Basta con ejecutar  docker run hello-world  para comprobar que la instalaci\u00f3n ha sido satisfactoria.", 
            "title": "Windows 10"
        }, 
        {
            "location": "/setup/#windows-7", 
            "text": "La \u00faltima versi\u00f3n de Docker para Windows solo est\u00e1 disponible a partir de Windows 10. Para utilizar Docker en versiones anteriores de Windows habr\u00e1 que usar  Docker Toolbox . B\u00e1sicamente consiste en:   Descargar el  instalador  y ejecutarlo.  Abrir  Docker Quickstart  (por defecto se instala un icono en el escritorio). La primera vez que se abra necesitar\u00e1 ejecutar unos cuantos pasos de configuraci\u00f3n inicial que pueden tomar un tiempo y que requieren permisos especiales que habr\u00e1 que aceptar.  Una vez se ha terminado la inicializaci\u00f3n se abrir\u00e1 una consola con el s\u00edmbolo  $ . Basta con ejecutar  docker run hello-world  para comprobar que la instalaci\u00f3n ha sido satisfactoria.", 
            "title": "Windows 7"
        }, 
        {
            "location": "/setup/#instalar-docker-compose", 
            "text": "docker-compose  es una herramienta de Docker que nos permite ejecutar, enlazar y en general gestionar varios contenedores de manera conjunta y sencilla.", 
            "title": "Instalar docker-compose"
        }, 
        {
            "location": "/setup/#linux", 
            "text": "La instalaci\u00f3n en Linux es muy sencilla. Basta con descargarlo y darle permisos de ejecuci\u00f3n:  curl -L https://github.com/docker/compose/releases/download/1.18.0/docker-compose- ` uname -s ` - ` uname -m `  -o /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\ndocker-compose --version", 
            "title": "Linux"
        }, 
        {
            "location": "/setup/#windows", 
            "text": "En Windows,  docker-compose  viene instalado tanto con  Docker for Windows  como con  Docker Toolbox , por lo que no ser\u00e1 necesario realizar nada m\u00e1s.", 
            "title": "Windows"
        }, 
        {
            "location": "/setup/#otros-sistemas-operativos", 
            "text": "Si el sistema operativo no se encuentra entre los anteriores, habr\u00e1 que dirigirse a la  documentaci\u00f3n  de Docker.", 
            "title": "Otros sistemas operativos"
        }, 
        {
            "location": "/setup/#arrancar-el-sistema", 
            "text": "En primer lugar deberemos crear nuestro directorio de trabajo, que incluye subdirectorios para GeoServer y el portal. Por ejemplo:  cd \nmkdir nfms\nmkdir nfms/geoserver\nmkdir nfms/geoladris   NOTA : A lo largo de esta documentaci\u00f3n se incluir\u00e1n \u00fanicamente los comandos  mkdir  de Linux, asumiendo que en Windows se crean mediante el explorador de archivos.   Despu\u00e9s, habr\u00e1 que descargarse los siguientes ficheros y copiarlos en el directorio de trabajo:   docker-compose.yml  context.xml  portal.zip  demo.war   Tras la descarga, habr\u00e1 que descomprimir el fichero  demo-*.war  (realmente es un fichero  .zip  con la extensi\u00f3n cambiada) en un directorio  portal  y descomprimir el fichero  portal.zip  dentro del directorio de configuraci\u00f3n  geoladris . El resultado deber\u00eda ser el siguiente:   Finalmente, bastar\u00e1 con arrancar el sistema con  docker-compose :  cd  ~/nfms\ndocker-compose up -d  O, en Windows, arrancando  Docker for Windows/Docker Toolbox :  cd   directorio \ndocker-compose up -d  Para comprobar que la instalaci\u00f3n y el arranque se han completado con \u00e9xito podemos acceder al portal en  http://localhost:8082/portal  y a GeoServer en  http://localhost:8081/geoserver .", 
            "title": "Arrancar el sistema"
        }, 
        {
            "location": "/client/hello_world/", 
            "text": "Lo primero que tendremos que hacer es crear un nuevo plugin en el directorio de plugins, dentro del directorio de configuraci\u00f3n del portal. Para m\u00e1s informaci\u00f3n sobre los plugins del portal, consultar la \ndocumentaci\u00f3n\n de la plataforma. Nuestro plugin se llamar\u00e1 \nhola-mundo\n:\n\n\nmkdir geoladris/portal/plugins/hola-mundo\n\n\n\n\n\nDentro de nuestro plugin, creamos un directorio \nsrc\n para el c\u00f3digo:\n\n\nmkdir geoladris/portal/plugins/hola-mundo/src\n\n\n\n\n\nY dentro de este directorio, creamos un nuevo fichero \nhola-mundo.js\n con el siguiente contenido:\n\n\nalert\n(\nHola mundo\n);\n\n\n\n\n\n\nAl recargar el portal nos encontraremos con el mensaje \nHola mundo\n nada m\u00e1s empezar.", 
            "title": "Hola mundo"
        }, 
        {
            "location": "/client/add_ui/", 
            "text": "En este caso vamos a a\u00f1adir un nuevo bot\u00f3n a la barra de herramientas del portal, que cuando se pulse muestre una alerta. Para ello crearemos un plugin llamado \nboton\n:\n\n\nmkdir -p geoladris/portal/plugins/boton/src\n\n\n\n\n\nY crearemos un fichero \nboton.js\n vac\u00edo.\n\n\nPara poder a\u00f1adir el bot\u00f3n necesitamos obtener el elemento HTML de la barra de herramientas. Este elemento lo podemos obtener mediante el m\u00f3dulo del plugin  \ntoolbar\n. Si nos fijamos en el m\u00f3dulo, podemos ver que devuelve un objeto jQuery con el elemento:\n\n\n  \n...\n\n  \nreturn\n \ndivToolbar\n;\n\n\n});\n\n\n\n\n\n\nPuesto que el portal funciona con \nRequireJS\n, bastar\u00e1 con definir nuestro m\u00f3dulo con \ntoolbar\n como dependencia:\n\n\ndefine\n([\n \ntoolbar\n \n],\n \nfunction\n(\ntoolbar\n)\n \n{\n\n  \n// Aqu\u00ed podemos utilizar toolbar como el objeto jQuery devuelto por el m\u00f3dulo\n\n\n});\n\n\n\n\n\n\nEn este punto podr\u00edamos realizar una prueba para comprobar que tenemos una referencia v\u00e1lida al elemento. El siguiente c\u00f3digo hace invisible la barra de herramientas:\n\n\ndefine\n([\n \ntoolbar\n \n],\n \nfunction\n(\ntoolbar\n)\n \n{\n\n  \ntoolbar\n.\nhide\n();\n\n\n});\n\n\n\n\n\n\nSi hemos hecho todos los pasos correctamente, veremos que la barra de herramientas no aparece, ya que la hemos escondido en nuestro m\u00f3dulo.\n\n\nLo \u00fanico que queda por hacer es reemplazar el c\u00f3digo de prueba anterior por otro que cree un bot\u00f3n. Esto lo podemos hacer creando un tag \nbutton\n con jQuery:\n\n\ndefine\n([\n \ntoolbar\n \n],\n \nfunction\n(\ntoolbar\n)\n \n{\n\n  \nlet\n \nbutton\n \n=\n \ndocument\n.\ncreateElement\n(\nbutton\n);\n\n  \nbutton\n.\nid\n \n=\n \nmiboton\n;\n\n  \nbutton\n.\nclassName\n \n=\n \nblue_button\n;\n\n  \nbutton\n.\ninnerHTML\n \n=\n \nP\u00falsame\n;\n\n  \nbutton\n.\naddEventListener\n(\nclick\n,\n \nfunction\n()\n \n{\n\n    \nalert\n(\nBot\u00f3n pulsado\n);\n\n  \n});\n\n\n  \ntoolbar\n.\nget\n(\n0\n).\nappendChild\n(\nbutton\n);\n\n\n});\n\n\n\n\n\n\nPor \u00faltimo podemos a\u00f1adir un fichero \nbot\u00f3n.css\n para dar estilo al bot\u00f3n:\n\n\nbutton\n.\nblue_button\n \n{\n\n  \nborder\n:\n \n0\n;\n\n\n}\n\n\n\n#\nmiboton\n \n{\n\n  \nmargin\n:\n \n12\npx\n;\n\n\n}", 
            "title": "A\u00f1adir elementos a la interfaz"
        }, 
        {
            "location": "/client/reuse/", 
            "text": "En este apartado vamos a crear un plugin que nos permita a\u00f1adir botones a la barra de herramientas de manera sencilla, para reutilizarlo desde otros plugins. En este caso, nuestro plugin se llama \nbotonera\n:\n\n\nmkdir -p geoladris/portal/plugins/botonera/src\n\n\n\n\n\nEn nuestro plugin debemos de dar la posibilidad a otros plugins para que a\u00f1adan elementos a la barra. Para ello vamos a hacer que nuestro plugin devuelva una funci\u00f3n en el fichero \ncrear.js\n. El c\u00f3digo de esta funci\u00f3n es pr\u00e1cticamente igual que el del plugin \nboton\n que implementamos anteriormente, pero recibiendo el texto del bot\u00f3n (\ntext\n) y una funci\u00f3n a ejecutar cuando se pulse (\ncallback\n):\n\n\ndefine\n([\n \ntoolbar\n \n],\n \nfunction\n(\ntoolbar\n)\n \n{\n\n  \nreturn\n \nfunction\n(\ntext\n,\n \ncallback\n)\n \n{\n\n    \nlet\n \nbutton\n \n=\n \ndocument\n.\ncreateElement\n(\nbutton\n);\n\n    \nbutton\n.\nclassName\n \n=\n \nblue_button\n;\n\n    \nbutton\n.\ninnerHTML\n \n=\n \ntext\n;\n\n    \nbutton\n.\naddEventListener\n(\nclick\n,\n \ncallback\n);\n\n\n    \ntoolbar\n.\nget\n(\n0\n).\nappendChild\n(\nbutton\n);\n\n  \n}\n\n\n});\n\n\n\n\n\n\nDespu\u00e9s, en otro m\u00f3dulo \nsaludo.js\n podemos utilizar el m\u00f3dulo \ncrear.js\n para a\u00f1adir un nuevo bot\u00f3n:\n\n\ndefine\n([\n \n./crear\n \n],\n \nfunction\n(\ncrear\n)\n \n{\n\n  \ncrear\n(\nSaludo\n,\n \nfunction\n()\n \n{\n\n    \nalert\n(\nHola mundo\n);\n\n  \n});\n\n\n});", 
            "title": "Reutilizar funcionalidad"
        }, 
        {
            "location": "/client/events/", 
            "text": "En el portal existe un bus de eventos que sirve para la comunicaci\u00f3n entre todos los m\u00f3dulos. Se recomienda leer una introducci\u00f3n a este \npatr\u00f3n de dise\u00f1o\n si no se est\u00e1 familiarizado con \u00e9l.\n\n\nEn este cap\u00edtulo veremos c\u00f3mo interactuar con la plataforma a trav\u00e9s de estos eventos. Para ello vamos a crear un plugin que oculte todas las capas del mapa a la vez:\n\n\nmkdir -p geoladris/portal/plugins/eventos/src\n\n\n\n\n\nEn este plugin tendremos que utilizar un \npatr\u00f3n\n muy habitual que consiste en hacer dos cosas:\n\n\n\n\nEscuchar eventos y recoger informaci\u00f3n de ellos.\n\n\nRealizar una acci\u00f3n con la informaci\u00f3n obtenida.\n\n\n\n\nEscuchando eventos\n\n\nPara ocultar las capas se utilizar\u00e1 el evento \nlayer-visibility\n, al que se pasa el identificador de la capa y el valor de visibilidad. El valor de visibilidad es siempre falso, pero adem\u00e1s se necesitar\u00e1 la lista de identificadores de todas las capas.\n\n\nPara obtenerlos, es necesario a\u00f1adir \nmessage-bus\n como dependencia, escuchar el evento \nadd-layer\n y guardar el identificador de cada capa en un array:\n\n\ndefine\n([\n \nmessage-bus\n \n],\n \nfunction\n(\nbus\n)\n \n{\n\n  \nlet\n \nlayerIds\n \n=\n \n[];\n\n\n  \nbus\n.\nlisten\n(\nadd-layer\n,\n \nfunction\n(\ne\n,\n \nlayerInfo\n)\n \n{\n\n    \nlayerIds\n.\npush\n(\nlayerInfo\n.\nid\n);\n\n  \n});\n\n\n});\n\n\n\n\n\n\nEnviando eventos\n\n\nUna vez recopilados todos los identificadores, solo queda lanzar el mensaje para cada una de las capas.\n\n\nEsto se har\u00e1 en respuesta a la pulsaci\u00f3n de un bot\u00f3n, utilizando el plugin \nbotonera\n que hemos creado antes:\n\n\ndefine\n([\n \nmessage-bus\n,\n \nbotonera/crear\n \n],\n \nfunction\n(\nbus\n,\n \ncrearBoton\n)\n \n{\n\n  \nlet\n \nlayerIds\n \n=\n \n[];\n\n\n  \nbus\n.\nlisten\n(\nadd-layer\n,\n \nfunction\n(\ne\n,\n \nlayerInfo\n)\n \n{\n\n    \nlayerIds\n.\npush\n(\nlayerInfo\n.\nid\n);\n\n  \n});\n\n\n  \ncrearBoton\n(\nTodas invisibles\n,\n \nfunction\n()\n \n{\n\n    \nlayerIds\n.\nforEach\n(\nfunction\n(\nid\n)\n \n{\n\n      \nbus\n.\nsend\n(\nlayer-visibility\n,\n \nid\n,\n \nfalse\n);\n\n    \n});\n\n  \n});\n\n\n});", 
            "title": "Manejar eventos"
        }, 
        {
            "location": "/client/events/#escuchando-eventos", 
            "text": "Para ocultar las capas se utilizar\u00e1 el evento  layer-visibility , al que se pasa el identificador de la capa y el valor de visibilidad. El valor de visibilidad es siempre falso, pero adem\u00e1s se necesitar\u00e1 la lista de identificadores de todas las capas.  Para obtenerlos, es necesario a\u00f1adir  message-bus  como dependencia, escuchar el evento  add-layer  y guardar el identificador de cada capa en un array:  define ([   message-bus   ],   function ( bus )   { \n   let   layerIds   =   []; \n\n   bus . listen ( add-layer ,   function ( e ,   layerInfo )   { \n     layerIds . push ( layerInfo . id ); \n   });  });", 
            "title": "Escuchando eventos"
        }, 
        {
            "location": "/client/events/#enviando-eventos", 
            "text": "Una vez recopilados todos los identificadores, solo queda lanzar el mensaje para cada una de las capas.  Esto se har\u00e1 en respuesta a la pulsaci\u00f3n de un bot\u00f3n, utilizando el plugin  botonera  que hemos creado antes:  define ([   message-bus ,   botonera/crear   ],   function ( bus ,   crearBoton )   { \n   let   layerIds   =   []; \n\n   bus . listen ( add-layer ,   function ( e ,   layerInfo )   { \n     layerIds . push ( layerInfo . id ); \n   }); \n\n   crearBoton ( Todas invisibles ,   function ()   { \n     layerIds . forEach ( function ( id )   { \n       bus . send ( layer-visibility ,   id ,   false ); \n     }); \n   });  });", 
            "title": "Enviando eventos"
        }, 
        {
            "location": "/client/add_map_functionality/", 
            "text": "Cada vez que se quiere a\u00f1adir un mapa OpenLayers en una p\u00e1gina web se comienza escribiendo c\u00f3digo en el que creamos el mapa:\n\n\nlet\n \nmap\n \n=\n \nnew\n \nOpenLayers\n.\nMap\n(\nmap\n,\n \n{\n\n  \ntheme\n \n:\n \nnull\n,\n\n  \nprojection\n \n:\n \nnew\n \nOpenLayers\n.\nProjection\n(\nEPSG:4326\n),\n\n  \nunits\n \n:\n \nm\n,\n\n  \nallOverlays\n \n:\n \ntrue\n,\n\n  \ncontrols\n \n:\n \n[]\n\n\n});\n\n\n\n\n\n\npara luego interactuar con \u00e9l a\u00f1adi\u00e9ndole capas, instalando controles, etc.:\n\n\nmap\n.\naddControl\n(\nnew\n \nOpenLayers\n.\nControl\n.\nNavigation\n();\n\n\nmap\n.\naddControl\n(\nnew\n \nOpenLayers\n.\nControl\n.\nMousePosition\n({\n\n  \nprefix\n \n:\n \na target=\n_blank\n href=\nhttp://spatialreference.org/ref/epsg/4326/\n \n+\n \nEPSG:4326\n/a\n coordinates: \n,\n\n  \nseparator\n \n:\n \n | \n,\n\n  \nnumDigits\n \n:\n \n2\n,\n\n  \nemptyString\n \n:\n \nMouse is not over map.\n\n\n}));\n\n\n\n\n\n\nSin embargo, en el portal ya existe un mapa creado. \u00bfC\u00f3mo podemos obtener una referencia al mapa para poder utilizarlo? Necesitaremos dos cosas:\n\n\n\n\nEscuchar el evento \nmodules-loaded\n para poder ejecutar nuestro c\u00f3digo en el \ncallback\n. Este evento se lanza cuando todos los m\u00f3dulos se han inicializado; es decir, han vuelto de la funci\u00f3n de inicializaci\u00f3n dentro del \ndefine\n. Escuchar este evento es necesario para asegurarnos de que el mapa est\u00e1 operativo.\n\n\nObtener la referencia al mapa mediante \nmap.getMap()\n. El m\u00f3dulo \nol2/map\n no devuelve el mapa de OpenLayers directamente, sino un objeto con funciones. Una de ellas es \ngetMap\n y sirve para obtener la instancia del mapa de OpenLayers. Esta funci\u00f3n solo se puede llamar una vez el evento \nmodules-loaded\n se ha enviado.\n\n\n\n\ndefine\n([\n \nmessage-bus\n,\n \nol2/map\n \n],\n \nfunction\n(\nbus\n,\n \nmap\n)\n \n{\n\n  \nbus\n.\nlisten\n(\nmodules-loaded\n,\n \nfunction\n()\n \n{\n\n    \nlet\n \nolmap\n \n=\n \nmap\n.\ngetMap\n();\n\n    \n...\n\n  \n});\n\n\n});\n\n\n\n\n\n\nEn este apartado vamos a crear un plugin que muestre las coordenadas que se est\u00e1n navegando. En este caso se llamar\u00e1 \ncoordenadas\n:\n\n\nmkdir -p geoladris/portal/plugins/coordenadas/src\n\n\n\n\n\nDentro crearemos un m\u00f3dulo \ncoordenadas.js\n con el siguiente contenido:\n\n\ndefine\n([\n \nmessage-bus\n,\n \nol2/map\n \n],\n \nfunction\n(\nbus\n,\n \nmap\n)\n \n{\n\n  \nbus\n.\nlisten\n(\nmodules-loaded\n,\n \nfunction\n()\n \n{\n\n    \nlet\n \nolmap\n \n=\n \nmap\n.\ngetMap\n();\n\n    \nlet\n \ncoords\n \n=\n \ndocument\n.\ncreateElement\n(\ndiv\n);\n\n    \ncoords\n.\nclassName\n \n=\n \nmapCoords\n;\n\n    \nolmap\n.\ndiv\n.\nappendChild\n(\ncoords\n);\n\n\n    \nlet\n \ncontrol\n \n=\n \nnew\n \nOpenLayers\n.\nControl\n.\nMousePosition\n({\n\n      \nprefix\n \n:\n \na target=\n_blank\n href=\nhttp://spatialreference.org/ref/epsg/4326/\nEPSG:4326\n/a\n coordinates: \n,\n\n      \ndiv\n \n:\n \ncoords\n,\n\n      \nseparator\n \n:\n \n | \n,\n\n      \nnumDigits\n \n:\n \n2\n,\n\n      \nemptyString\n \n:\n \nMouse is not over map.\n\n    \n});\n\n    \nolmap\n.\naddControl\n(\ncontrol\n);\n\n  \n});\n\n\n});\n\n\n\n\n\n\nEn el c\u00f3digo podemos observar c\u00f3mo se a\u00f1ade un elemento (\ncoords\n) al elemento que contiene el mapa (\nolmap.div\n) para luego a\u00f1adir un nuevo control (\nOpenLayers.Control.MousePosition\n) al mapa, utilizando ese elemento.\n\n\nPor \u00faltimo, a\u00f1adiremos algo de estilo al elemento que muestra las coordenadas:\n\n\n.\nmapCoords\n \n{\n\n  \nposition\n:\n \nabsolute\n;\n\n  \nbottom\n:\n \n30\npx\n;\n\n  \nleft\n:\n \n0\npx\n;\n\n  \nbackground\n:\n \nwhite\n;\n\n  \npadding\n:\n \n10\npx\n;\n\n  \nborder\n:\n \n1\npx\n \nsolid\n \ngray\n;\n\n  \nz-index\n:\n \n999\n;\n\n\n}\n\n\n\n\n\n\nY, al recargar el portal, tendremos nuestro control de coordenadas.", 
            "title": "A\u00f1adir funcionalidad al mapa"
        }, 
        {
            "location": "/server/hello_world/", 
            "text": "En este curso vamos a crear un nuevo servicio o \nservlet\n que nos devuelve un mensaje \"hola mundo\" en texto plano o XML, en funci\u00f3n de un par\u00e1metro.\n\n\nLos \nservlets\n son programas Java que se ejecutan en un servidor como respuesta a la petici\u00f3n de un cliente.\n\n\nCreando el proyecto\n\n\nPuesto que queremos que la funcionalidad sea reutilizable, deberemos meter este servlet dentro de un plugin. Los plugins son proyectos Java que creamos con Maven.\n\n\nEn primer lugar, necesitaremos crear el esqueleto de un proyecto para poder trabajar. Lo podemos conseguir con el siguiente comando:\n\n\n$ mvn archetype:generate -DgroupId\n=\norg.fao.unredd -DartifactId\n=\nhola-mundo -DarchetypeArtifactId\n=\nmaven-archetype-quickstart -DinteractiveMode\n=\nfalse\n\n\n\n\n\n\nque crear\u00e1 un directorio \nhola-mundo\n con los ficheros y subdirectorios necesarios.\n\n\nEl fichero m\u00e1s importante para Maven es el fichero \npom.xml\n, donde se define todo el funcionamiento del proyecto. En nuestro caso lo que queremos hacer es incluir las dependencias necesarias para los servlets:\n\n\nproject\n \n...\n\n  ...\n  \ndependencies\n\n    ...\n    \ndependency\n\n        \ngroupId\njavax.servlet\n/groupId\n\n        \nartifactId\njavax.servlet-api\n/artifactId\n\n        \nversion\n3.0.1\n/version\n\n        \nscope\nprovided\n/scope\n\n    \n/dependency\n\n  \n/dependencies\n\n\n/project\n\n\n\n\n\n\nCreando el servlet\n\n\nLo primero que tenemos que hacer es crear un fichero \nweb-fragment.xml\n en \nsrc/main/resources/META-INF\n (habr\u00e1 que crear el directorio) donde especificamos nuestro servicio:\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nweb-fragment\n \nversion=\n3.0\n \nxmlns=\nhttp://java.sun.com/xml/ns/javaee\n\n    \nxmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n    \nxsi:schemaLocation=\nhttp://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd\n\n  \nservlet\n\n    \nservlet-name\nholamundo-servlet\n/servlet-name\n\n    \nservlet-class\norg.fao.unredd.HolaMundoServlet\n/servlet-class\n\n  \n/servlet\n\n  \nservlet-mapping\n\n    \nservlet-name\nholamundo-servlet\n/servlet-name\n\n    \nurl-pattern\n/holamundo\n/url-pattern\n\n  \n/servlet-mapping\n\n\n/web-fragment\n\n\n\n\n\n\nEn este fichero estamos asociando el servlet \nholamundo-servlet\n con la URL \n/holamundo\n y adem\u00e1s estamos indicando que lo implementa con la clase \norg.fao.unredd.HolaMundoServlet\n. Ahora s\u00f3lo tenemos que implementarla:\n\n\npackage\n \norg.fao.unredd\n;\n\n\n\nimport\n \njavax.servlet.http.HttpServlet\n;\n\n\n\npublic\n \nclass\n \nHolaMundoServlet\n \nextends\n \nHttpServlet\n{\n\n\n}\n\n\n\n\n\n\nLa \u00fanica particularidad del c\u00f3digo anterior es que el servlet debe extender a \njavax.servlet.http.HttpServlet\n.\n\n\nLlegados a este punto tenemos que empaquetar nuestro plugin y desplegarlo con el portal. Para ello, primero empaquetamos nuestro plugin y lo instalamos en local:\n\n\ncd\n hola-mundo\nmvn package\n\n\n\n\n\nPosteriormente, tendremos que copiar nuestro plugin en el directorio de plugins de la aplicaci\u00f3n, dentro de Tomcat:\n\n\ncp target/hola-mundo-1.0-SNAPSHOT.jar ../portal/WEB-INF/lib\n\n\n\n\n\ny luego, reiniciaremos el portal:\n\n\ncd\n ..\ndocker-compose restart portal\n\n\n\n\n\nSi hemos hecho todo correctamente ser\u00e1 posible, previo reinicio del servidor, acceder a la URL \nhttp://localhost/portal/holamundo\n y obtener un error \n405: Method Not Allowed\n (m\u00e9todo no permitido). Podemos comprobar que el mensaje es distinto si accedemos a una URL inexistente, como \nhttp://localhost/portal/holamundonoexiste\n, donde obtenemos \n404: Not Found\n (no encontrado).\n\n\nEsto quiere decir que el servlet est\u00e1 bien instalado. S\u00f3lo hace falta implementar el m\u00e9todo GET, que es el que est\u00e1 pidiendo el navegador:\n\n\npackage\n \norg.fao.unredd\n;\n\n\n\nimport\n \njava.io.IOException\n;\n\n\n\nimport\n \njavax.servlet.ServletException\n;\n\n\nimport\n \njavax.servlet.http.HttpServlet\n;\n\n\nimport\n \njavax.servlet.http.HttpServletRequest\n;\n\n\nimport\n \njavax.servlet.http.HttpServletResponse\n;\n\n\n\npublic\n \nclass\n \nHolaMundoServlet\n \nextends\n \nHttpServlet\n{\n\n\n  \n@Override\n\n  \nprotected\n \nvoid\n \ndoGet\n(\nHttpServletRequest\n \nreq\n,\n \nHttpServletResponse\n \nresp\n)\n\n      \nthrows\n \nServletException\n,\n \nIOException\n \n{\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSi volvemos a instalar en local, empaquetar y desplegar el plugin, el servidor debe devolver una p\u00e1gina en blanco, pero no debe dar un error. Se llega as\u00ed al punto en el que leeremos el par\u00e1metro y en funci\u00f3n de este devolveremos un XML o texto plano:\n\n\npackage\n \norg.fao.unredd\n;\n\n\n\nimport\n \njava.io.IOException\n;\n\n\n\nimport\n \njavax.servlet.ServletException\n;\n\n\nimport\n \njavax.servlet.http.HttpServlet\n;\n\n\nimport\n \njavax.servlet.http.HttpServletRequest\n;\n\n\nimport\n \njavax.servlet.http.HttpServletResponse\n;\n\n\n\npublic\n \nclass\n \nHolaMundoServlet\n \nextends\n \nHttpServlet\n \n{\n\n\n  \n@Override\n\n  \nprotected\n \nvoid\n \ndoGet\n(\nHttpServletRequest\n \nreq\n,\n \nHttpServletResponse\n \nresp\n)\n\n      \nthrows\n \nServletException\n,\n \nIOException\n \n{\n\n    \nString\n \noutputformat\n \n=\n \nreq\n.\ngetParameter\n(\noutputformat\n);\n\n    \nresp\n.\nsetCharacterEncoding\n(\nutf-8\n);\n\n    \nif\n \n(\nxml\n.\nequals\n(\noutputformat\n))\n \n{\n\n      \nresp\n.\nsetContentType\n(\napplication/xml\n);\n\n      \nresp\n.\ngetWriter\n().\nwrite\n(\nresponse\nhola mundo\n/response\n);\n\n    \n}\n \nelse\n \n{\n\n      \nresp\n.\nsetContentType\n(\ntext/plain\n);\n\n      \nresp\n.\ngetWriter\n().\nwrite\n(\nhola mundo\n);\n\n    \n}\n\n  \n}\n\n\n}", 
            "title": "Hola mundo"
        }, 
        {
            "location": "/server/hello_world/#creando-el-proyecto", 
            "text": "Puesto que queremos que la funcionalidad sea reutilizable, deberemos meter este servlet dentro de un plugin. Los plugins son proyectos Java que creamos con Maven.  En primer lugar, necesitaremos crear el esqueleto de un proyecto para poder trabajar. Lo podemos conseguir con el siguiente comando:  $ mvn archetype:generate -DgroupId = org.fao.unredd -DartifactId = hola-mundo -DarchetypeArtifactId = maven-archetype-quickstart -DinteractiveMode = false   que crear\u00e1 un directorio  hola-mundo  con los ficheros y subdirectorios necesarios.  El fichero m\u00e1s importante para Maven es el fichero  pom.xml , donde se define todo el funcionamiento del proyecto. En nuestro caso lo que queremos hacer es incluir las dependencias necesarias para los servlets:  project   ... \n  ...\n   dependencies \n    ...\n     dependency \n         groupId javax.servlet /groupId \n         artifactId javax.servlet-api /artifactId \n         version 3.0.1 /version \n         scope provided /scope \n     /dependency \n   /dependencies  /project", 
            "title": "Creando el proyecto"
        }, 
        {
            "location": "/server/hello_world/#creando-el-servlet", 
            "text": "Lo primero que tenemos que hacer es crear un fichero  web-fragment.xml  en  src/main/resources/META-INF  (habr\u00e1 que crear el directorio) donde especificamos nuestro servicio:  ?xml version= 1.0  encoding= UTF-8 ?  web-fragment   version= 3.0   xmlns= http://java.sun.com/xml/ns/javaee \n     xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n     xsi:schemaLocation= http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd \n   servlet \n     servlet-name holamundo-servlet /servlet-name \n     servlet-class org.fao.unredd.HolaMundoServlet /servlet-class \n   /servlet \n   servlet-mapping \n     servlet-name holamundo-servlet /servlet-name \n     url-pattern /holamundo /url-pattern \n   /servlet-mapping  /web-fragment   En este fichero estamos asociando el servlet  holamundo-servlet  con la URL  /holamundo  y adem\u00e1s estamos indicando que lo implementa con la clase  org.fao.unredd.HolaMundoServlet . Ahora s\u00f3lo tenemos que implementarla:  package   org.fao.unredd ;  import   javax.servlet.http.HttpServlet ;  public   class   HolaMundoServlet   extends   HttpServlet {  }   La \u00fanica particularidad del c\u00f3digo anterior es que el servlet debe extender a  javax.servlet.http.HttpServlet .  Llegados a este punto tenemos que empaquetar nuestro plugin y desplegarlo con el portal. Para ello, primero empaquetamos nuestro plugin y lo instalamos en local:  cd  hola-mundo\nmvn package  Posteriormente, tendremos que copiar nuestro plugin en el directorio de plugins de la aplicaci\u00f3n, dentro de Tomcat:  cp target/hola-mundo-1.0-SNAPSHOT.jar ../portal/WEB-INF/lib  y luego, reiniciaremos el portal:  cd  ..\ndocker-compose restart portal  Si hemos hecho todo correctamente ser\u00e1 posible, previo reinicio del servidor, acceder a la URL  http://localhost/portal/holamundo  y obtener un error  405: Method Not Allowed  (m\u00e9todo no permitido). Podemos comprobar que el mensaje es distinto si accedemos a una URL inexistente, como  http://localhost/portal/holamundonoexiste , donde obtenemos  404: Not Found  (no encontrado).  Esto quiere decir que el servlet est\u00e1 bien instalado. S\u00f3lo hace falta implementar el m\u00e9todo GET, que es el que est\u00e1 pidiendo el navegador:  package   org.fao.unredd ;  import   java.io.IOException ;  import   javax.servlet.ServletException ;  import   javax.servlet.http.HttpServlet ;  import   javax.servlet.http.HttpServletRequest ;  import   javax.servlet.http.HttpServletResponse ;  public   class   HolaMundoServlet   extends   HttpServlet { \n\n   @Override \n   protected   void   doGet ( HttpServletRequest   req ,   HttpServletResponse   resp ) \n       throws   ServletException ,   IOException   { \n   }  }   Si volvemos a instalar en local, empaquetar y desplegar el plugin, el servidor debe devolver una p\u00e1gina en blanco, pero no debe dar un error. Se llega as\u00ed al punto en el que leeremos el par\u00e1metro y en funci\u00f3n de este devolveremos un XML o texto plano:  package   org.fao.unredd ;  import   java.io.IOException ;  import   javax.servlet.ServletException ;  import   javax.servlet.http.HttpServlet ;  import   javax.servlet.http.HttpServletRequest ;  import   javax.servlet.http.HttpServletResponse ;  public   class   HolaMundoServlet   extends   HttpServlet   { \n\n   @Override \n   protected   void   doGet ( HttpServletRequest   req ,   HttpServletResponse   resp ) \n       throws   ServletException ,   IOException   { \n     String   outputformat   =   req . getParameter ( outputformat ); \n     resp . setCharacterEncoding ( utf-8 ); \n     if   ( xml . equals ( outputformat ))   { \n       resp . setContentType ( application/xml ); \n       resp . getWriter (). write ( response hola mundo /response ); \n     }   else   { \n       resp . setContentType ( text/plain ); \n       resp . getWriter (). write ( hola mundo ); \n     } \n   }  }", 
            "title": "Creando el servlet"
        }, 
        {
            "location": "/server/config_servlet/", 
            "text": "En este caso vamos a crear un servlet que nos permita modificar el centro en el que se carga el mapa al arrancar.\n\n\nEl centro del mapa se define en las propiedades \nmap.centerLonLat\n y \nmap.initialZoomLevel\n del fichero \nportal.properties\n, por lo que nuestro servlet deber\u00e1 modificar ese fichero con las coordenadas enviadas desde el navegador.\n\n\nCreando el proyecto\n\n\nEn primer lugar, volvemos a crear un esqueleto para nuestro plugin:\n\n\n$ mvn archetype:generate -DgroupId\n=\norg.fao.unredd -DartifactId\n=\nguardar-centro -DarchetypeArtifactId\n=\nmaven-archetype-quickstart -DinteractiveMode\n=\nfalse\n\n\n\n\n\n\nVolvemos a a\u00f1adir las dependencias necesarias para los servlets y para trabajar con la configuraci\u00f3n de Geoladris:\n\n\nproject\n \n...\n\n  ...\n  \ndependencies\n\n    ...\n    \ndependency\n\n        \ngroupId\njavax.servlet\n/groupId\n\n        \nartifactId\njavax.servlet-api\n/artifactId\n\n        \nversion\n3.0.1\n/version\n\n        \nscope\nprovided\n/scope\n\n    \n/dependency\n\n    \ndependency\n\n        \ngroupId\ncom.github.geoladris\n/groupId\n\n        \nartifactId\ncore\n/artifactId\n\n        \nversion\n7.0.0\n/version\n\n    \n/dependency\n\n  \n/dependencies\n\n\n/project\n\n\n\n\n\n\ny configuramos nuestro fichero \nsrc/main/resources/META-INF/web-fragment.xml\n:\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nweb-fragment\n \nversion=\n3.0\n \nxmlns=\nhttp://java.sun.com/xml/ns/javaee\n\n    \nxmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n    \nxsi:schemaLocation=\nhttp://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd\n\n  \nservlet\n\n    \nservlet-name\nguardar-centro-servlet\n/servlet-name\n\n    \nservlet-class\norg.fao.unredd.GuardarCentroServlet\n/servlet-class\n\n  \n/servlet\n\n  \nservlet-mapping\n\n    \nservlet-name\nguardar-centro-servlet\n/servlet-name\n\n    \nurl-pattern\n/guardar-centro\n/url-pattern\n\n  \n/servlet-mapping\n\n\n/web-fragment\n\n\n\n\n\n\nCreando el servlet\n\n\nAhora, deberemos implementar el servlet. Para ello, primero debemos obtener una referencia al fichero \nportal.properties\n, que est\u00e1 dentro del directorio de configuraci\u00f3n.\n\n\nPara esto, existe un objeto \nConfig\n, que se puede obtener en los servlets de la siguiente manera:\n\n\nConfig\n \nconfig\n \n=\n \n(\nConfig\n)\n \ngetServletContext\n().\ngetAttribute\n(\nGeoladris\n.\nATTR_CONFIG\n);\n\n\n\n\n\n\ny que nos permite obtener el directorio de configuraci\u00f3n y, por tanto, el fichero \nportal.properties\n:\n\n\nFile\n \npropertiesFile\n \n=\n \nnew\n \nFile\n(\nconfig\n.\ngetDir\n(),\n \nportal.properties\n);\n\n\n\n\n\n\nUna vez tenemos el fichero, cargaremos todas las propiedades en un objeto \nProperties\n:\n\n\nProperties\n \nproperties\n \n=\n \nnew\n \nProperties\n();\n\n\nInputStream\n \ninStream\n \n=\n \nnew\n \nFileInputStream\n(\npropertiesFile\n);\n\n\nproperties\n.\nload\n(\ninStream\n);\n\n\ninStream\n.\nclose\n();\n\n\n\n\n\n\nmodificaremos las propiedades a partir de los par\u00e1metros enviados:\n\n\nproperties\n.\nput\n(\nmap.centerLonLat\n,\n \nreq\n.\ngetParameter\n(\nlon\n)\n \n+\n \n,\n \n+\n \nreq\n.\ngetParameter\n(\nlat\n));\n\n\nproperties\n.\nput\n(\nmap.initialZoomLevel\n,\n \nreq\n.\ngetParameter\n(\nzoomLevel\n));\n\n\n\n\n\n\ny guardaremos los cambios en el fichero:\n\n\nOutputStream\n \noutStream\n \n=\n \nnew\n \nFileOutputStream\n(\npropertiesFile\n);\n\n\nproperties\n.\nstore\n(\noutStream\n,\n \nnull\n);\n\n\noutStream\n.\nclose\n();\n\n\n\n\n\n\nAqu\u00ed se puede ver el servlet completo:\n\n\npackage\n \norg.fao.unredd\n;\n\n\n\nimport\n \njava.io.File\n;\n\n\nimport\n \njava.io.FileInputStream\n;\n\n\nimport\n \njava.io.FileOutputStream\n;\n\n\nimport\n \njava.io.IOException\n;\n\n\nimport\n \njava.io.InputStream\n;\n\n\nimport\n \njava.io.OutputStream\n;\n\n\nimport\n \njava.util.Properties\n;\n\n\n\nimport\n \njavax.servlet.ServletException\n;\n\n\nimport\n \njavax.servlet.http.HttpServlet\n;\n\n\nimport\n \njavax.servlet.http.HttpServletRequest\n;\n\n\nimport\n \njavax.servlet.http.HttpServletResponse\n;\n\n\n\nimport\n \norg.geoladris.Geoladris\n;\n\n\nimport\n \norg.geoladris.config.Config\n;\n\n\n\npublic\n \nclass\n \nGuardarCentroServlet\n \nextends\n \nHttpServlet\n \n{\n\n\n  \n@Override\n\n  \nprotected\n \nvoid\n \ndoGet\n(\nHttpServletRequest\n \nreq\n,\n \nHttpServletResponse\n \nresp\n)\n\n      \nthrows\n \nServletException\n,\n \nIOException\n \n{\n\n    \nConfig\n \nconfig\n \n=\n \n(\nConfig\n)\n \ngetServletContext\n().\ngetAttribute\n(\nGeoladris\n.\nATTR_CONFIG\n);\n\n    \nFile\n \npropertiesFile\n \n=\n \nnew\n \nFile\n(\nconfig\n.\ngetDir\n(),\n \nportal.properties\n);\n\n\n    \nProperties\n \nproperties\n \n=\n \nnew\n \nProperties\n();\n\n    \nInputStream\n \ninStream\n \n=\n \nnew\n \nFileInputStream\n(\npropertiesFile\n);\n\n    \nproperties\n.\nload\n(\ninStream\n);\n\n    \ninStream\n.\nclose\n();\n\n\n    \nproperties\n.\nput\n(\nmap.centerLonLat\n,\n \nreq\n.\ngetParameter\n(\nlon\n)\n \n+\n \n,\n \n+\n \nreq\n.\ngetParameter\n(\nlat\n));\n\n    \nproperties\n.\nput\n(\nmap.initialZoomLevel\n,\n \nreq\n.\ngetParameter\n(\nzoomLevel\n));\n\n\n    \nOutputStream\n \noutStream\n \n=\n \nnew\n \nFileOutputStream\n(\npropertiesFile\n);\n\n    \nproperties\n.\nstore\n(\noutStream\n,\n \nnull\n);\n\n    \noutStream\n.\nclose\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\nAhora, para probarlo tendremos que crear un plugin cliente con un bot\u00f3n que ,cuando se pulse, llame al servlet que acabamos de crear enviando el centro del mapa en ese momento. Bastar\u00e1 crear un nuevo plugin con el siguiente m\u00f3dulo (para m\u00e1s detalles ver apartados sobre \ncliente\n):\n\n\ndefine\n([\n \nmessage-bus\n,\n \nbotonera/crear\n,\n \nol2/map\n \n],\n \nfunction\n(\nbus\n,\n \nbotonera\n,\n \nolmap\n)\n \n{\n\n  \nbotonera\n(\nguardar centro\n,\n \nfunction\n()\n \n{\n\n    \nvar\n \nmap\n \n=\n \nolmap\n.\ngetMap\n();\n\n    \nvar\n \ncenter\n \n=\n \nmap\n.\ngetCenter\n();\n\n    \ncenter\n.\ntransform\n(\nnew\n \nOpenLayers\n.\nProjection\n(\nEPSG:900913\n),\n \nnew\n \nOpenLayers\n.\nProjection\n(\nEPSG:4326\n));\n\n    \nvar\n \nzoomLevel\n \n=\n \nmap\n.\ngetZoom\n();\n\n    \nbus\n.\nsend\n(\najax\n,\n \n{\n\n      \nurl\n \n:\n \nguardar-centro?lon=\n \n+\n \ncenter\n.\nlon\n \n+\n \nlat=\n \n+\n \ncenter\n.\nlat\n \n+\n \nzoomLevel=\n \n+\n \nzoomLevel\n,\n\n      \nsuccess\n \n:\n \nfunction\n(\nindicators\n,\n \ntextStatus\n,\n \njqXHR\n)\n \n{\n\n        \nalert\n(\ncentro guardado\n);\n\n      \n},\n\n      \nerrorMsg\n \n:\n \nNo se pudo guardar el centro\n\n    \n});\n\n  \n});\n\n\n});\n\n\n\n\n\n\nPor \u00faltimo, deber\u00edamos poder instalar empaquetar nuestro plugin y reiniciar el portal para poder utilizar nuestro bot\u00f3n enlazado con nuestro servlet.\n\n\nManejando errores\n\n\nEl servlet anterior parte de la base de que las peticiones que se hagan van a ser satisfactorias, se va a guardar el centro. Pero en la realidad esto no es la norma general. \u00bfQu\u00e9 sucede si la petici\u00f3n no incluye los par\u00e1metros \nlon\n, \nlat\n, o \nzoomLevel\n? \u00bfQu\u00e9 pasa si el fichero \nportal.properties\n ha sido eliminado?\n\n\nEl est\u00e1ndar HTML define una serie de c\u00f3digos que pueden ayudar en la comunicaci\u00f3n de estas condiciones excepcionales:\n\n\n\n\nOk (200)\n: Ejecuci\u00f3n satisfactoria.\n\n\nBad Request (400)\n: La petici\u00f3n no pudo ser entendida por el servidor. Aqu\u00ed se puede indicar que no fue especificado el par\u00e1metro. Es posible acompa\u00f1ar el c\u00f3digo con un mensaje descriptivo.\n\n\nInternal server error (500)\n: Adecuado para indicar errores graves, irrecuperables, como un bug en el c\u00f3digo o que el fichero \nportal.properties\n.\n\n\n\n\nPara utilizar estos errores, basta con utilizar el m\u00e9todo \nHttpServletResponse.sendError\n:\n\n\nPor ejemplo, en caso de que se desee enviar un c\u00f3digo \nBad Request (400)\n cuando el par\u00e1metro \nlon\n no est\u00e9 presente:\n\n\nif\n \n(\nlon\n \n==\n \nnull\n)\n \n{\n\n  \nresp\n.\nsendError\n(\nHttpServletResponse\n.\nSC_BAD_REQUEST\n);\n\n  \nreturn\n;\n\n\n}\n\n\n\n\n\n\nTeniendo esto en cuenta, el servlet se podr\u00eda escribir as\u00ed:\n\n\npackage\n \norg.fao.unredd\n;\n\n\n\nimport\n \njava.io.File\n;\n\n\nimport\n \njava.io.FileInputStream\n;\n\n\nimport\n \njava.io.FileOutputStream\n;\n\n\nimport\n \njava.io.IOException\n;\n\n\nimport\n \njava.io.InputStream\n;\n\n\nimport\n \njava.io.OutputStream\n;\n\n\nimport\n \njava.util.Properties\n;\n\n\n\nimport\n \njavax.servlet.ServletException\n;\n\n\nimport\n \njavax.servlet.http.HttpServlet\n;\n\n\nimport\n \njavax.servlet.http.HttpServletRequest\n;\n\n\nimport\n \njavax.servlet.http.HttpServletResponse\n;\n\n\n\nimport\n \norg.geoladris.Geoladris\n;\n\n\nimport\n \norg.geoladris.config.Config\n;\n\n\n\npublic\n \nclass\n \nGuardarCentroServlet\n \nextends\n \nHttpServlet\n \n{\n\n\n  \n@Override\n\n  \nprotected\n \nvoid\n \ndoGet\n(\nHttpServletRequest\n \nreq\n,\n \nHttpServletResponse\n \nresp\n)\n\n      \nthrows\n \nServletException\n,\n \nIOException\n \n{\n\n    \nConfig\n \nconfig\n \n=\n \n(\nConfig\n)\n \ngetServletContext\n().\ngetAttribute\n(\nGeoladris\n.\nATTR_CONFIG\n);\n\n    \nFile\n \npropertiesFile\n \n=\n \nnew\n \nFile\n(\nconfig\n.\ngetDir\n(),\n \nportal.properties\n);\n\n    \nProperties\n \nproperties\n \n=\n \nnew\n \nProperties\n();\n\n    \nString\n \nlon\n \n=\n \nreq\n.\ngetParameter\n(\nlon\n);\n\n    \nString\n \nlat\n \n=\n \nreq\n.\ngetParameter\n(\nlat\n);\n\n    \nString\n \nzoomLevel\n \n=\n \nreq\n.\ngetParameter\n(\nzoomLevel\n);\n\n\n    \nif\n \n(\nlon\n \n==\n \nnull\n \n||\n \nlat\n \n==\n \nnull\n \n||\n \nzoomLevel\n \n==\n \nnull\n)\n \n{\n\n      \nresp\n.\nsendError\n(\nHttpServletResponse\n.\nSC_BAD_REQUEST\n,\n \nLos par\u00e1metros lon, lat y zoomLevel son obligatorios.\n);\n\n      \nreturn\n;\n\n    \n}\n\n\n    \n// Lectura del fichero\n\n    \ntry\n \n{\n\n      \nFileInputStream\n \ninputStream\n \n=\n \nnew\n \nFileInputStream\n(\npropertiesFile\n);\n\n      \nproperties\n.\nload\n(\ninputStream\n);\n\n      \ninputStream\n.\nclose\n();\n\n    \n}\n \ncatch\n \n(\nIOException\n \ne\n)\n \n{\n\n      \nresp\n.\nsendError\n(\nHttpServletResponse\n.\nSC_INTERNAL_SERVER_ERROR\n,\n \nError grave en el servidor. Contacte al administrador\n);\n\n      \nreturn\n;\n\n    \n}\n\n\n    \nproperties\n.\nput\n(\nmap.centerLonLat\n,\n \nreq\n.\ngetParameter\n(\nlon\n)\n \n+\n \n,\n \n+\n \nreq\n.\ngetParameter\n(\nlat\n));\n\n    \nproperties\n.\nput\n(\nmap.initialZoomLevel\n,\n \nreq\n.\ngetParameter\n(\nzoomLevel\n));\n\n\n    \n// Escritura del fichero\n\n    \ntry\n \n{\n\n      \nFileOutputStream\n \noutputStream\n \n=\n \nnew\n \nFileOutputStream\n(\npropertiesFile\n);\n\n      \nproperties\n.\nstore\n(\noutputStream\n,\n \nnull\n);\n\n      \noutputStream\n.\nclose\n();\n\n    \n}\n \ncatch\n \n(\nIOException\n \ne\n)\n \n{\n\n      \nresp\n.\nsendError\n(\nHttpServletResponse\n.\nSC_INTERNAL_SERVER_ERROR\n,\n \nError grave en el servidor. Contacte al administrador\n);\n\n      \nreturn\n;\n\n    \n}\n\n  \n}\n\n\n}", 
            "title": "Servlet de configuraci\u00f3n"
        }, 
        {
            "location": "/server/config_servlet/#creando-el-proyecto", 
            "text": "En primer lugar, volvemos a crear un esqueleto para nuestro plugin:  $ mvn archetype:generate -DgroupId = org.fao.unredd -DartifactId = guardar-centro -DarchetypeArtifactId = maven-archetype-quickstart -DinteractiveMode = false   Volvemos a a\u00f1adir las dependencias necesarias para los servlets y para trabajar con la configuraci\u00f3n de Geoladris:  project   ... \n  ...\n   dependencies \n    ...\n     dependency \n         groupId javax.servlet /groupId \n         artifactId javax.servlet-api /artifactId \n         version 3.0.1 /version \n         scope provided /scope \n     /dependency \n     dependency \n         groupId com.github.geoladris /groupId \n         artifactId core /artifactId \n         version 7.0.0 /version \n     /dependency \n   /dependencies  /project   y configuramos nuestro fichero  src/main/resources/META-INF/web-fragment.xml :  ?xml version= 1.0  encoding= UTF-8 ?  web-fragment   version= 3.0   xmlns= http://java.sun.com/xml/ns/javaee \n     xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n     xsi:schemaLocation= http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd \n   servlet \n     servlet-name guardar-centro-servlet /servlet-name \n     servlet-class org.fao.unredd.GuardarCentroServlet /servlet-class \n   /servlet \n   servlet-mapping \n     servlet-name guardar-centro-servlet /servlet-name \n     url-pattern /guardar-centro /url-pattern \n   /servlet-mapping  /web-fragment", 
            "title": "Creando el proyecto"
        }, 
        {
            "location": "/server/config_servlet/#creando-el-servlet", 
            "text": "Ahora, deberemos implementar el servlet. Para ello, primero debemos obtener una referencia al fichero  portal.properties , que est\u00e1 dentro del directorio de configuraci\u00f3n.  Para esto, existe un objeto  Config , que se puede obtener en los servlets de la siguiente manera:  Config   config   =   ( Config )   getServletContext (). getAttribute ( Geoladris . ATTR_CONFIG );   y que nos permite obtener el directorio de configuraci\u00f3n y, por tanto, el fichero  portal.properties :  File   propertiesFile   =   new   File ( config . getDir (),   portal.properties );   Una vez tenemos el fichero, cargaremos todas las propiedades en un objeto  Properties :  Properties   properties   =   new   Properties ();  InputStream   inStream   =   new   FileInputStream ( propertiesFile );  properties . load ( inStream );  inStream . close ();   modificaremos las propiedades a partir de los par\u00e1metros enviados:  properties . put ( map.centerLonLat ,   req . getParameter ( lon )   +   ,   +   req . getParameter ( lat ));  properties . put ( map.initialZoomLevel ,   req . getParameter ( zoomLevel ));   y guardaremos los cambios en el fichero:  OutputStream   outStream   =   new   FileOutputStream ( propertiesFile );  properties . store ( outStream ,   null );  outStream . close ();   Aqu\u00ed se puede ver el servlet completo:  package   org.fao.unredd ;  import   java.io.File ;  import   java.io.FileInputStream ;  import   java.io.FileOutputStream ;  import   java.io.IOException ;  import   java.io.InputStream ;  import   java.io.OutputStream ;  import   java.util.Properties ;  import   javax.servlet.ServletException ;  import   javax.servlet.http.HttpServlet ;  import   javax.servlet.http.HttpServletRequest ;  import   javax.servlet.http.HttpServletResponse ;  import   org.geoladris.Geoladris ;  import   org.geoladris.config.Config ;  public   class   GuardarCentroServlet   extends   HttpServlet   { \n\n   @Override \n   protected   void   doGet ( HttpServletRequest   req ,   HttpServletResponse   resp ) \n       throws   ServletException ,   IOException   { \n     Config   config   =   ( Config )   getServletContext (). getAttribute ( Geoladris . ATTR_CONFIG ); \n     File   propertiesFile   =   new   File ( config . getDir (),   portal.properties ); \n\n     Properties   properties   =   new   Properties (); \n     InputStream   inStream   =   new   FileInputStream ( propertiesFile ); \n     properties . load ( inStream ); \n     inStream . close (); \n\n     properties . put ( map.centerLonLat ,   req . getParameter ( lon )   +   ,   +   req . getParameter ( lat )); \n     properties . put ( map.initialZoomLevel ,   req . getParameter ( zoomLevel )); \n\n     OutputStream   outStream   =   new   FileOutputStream ( propertiesFile ); \n     properties . store ( outStream ,   null ); \n     outStream . close (); \n   }  }   Ahora, para probarlo tendremos que crear un plugin cliente con un bot\u00f3n que ,cuando se pulse, llame al servlet que acabamos de crear enviando el centro del mapa en ese momento. Bastar\u00e1 crear un nuevo plugin con el siguiente m\u00f3dulo (para m\u00e1s detalles ver apartados sobre  cliente ):  define ([   message-bus ,   botonera/crear ,   ol2/map   ],   function ( bus ,   botonera ,   olmap )   { \n   botonera ( guardar centro ,   function ()   { \n     var   map   =   olmap . getMap (); \n     var   center   =   map . getCenter (); \n     center . transform ( new   OpenLayers . Projection ( EPSG:900913 ),   new   OpenLayers . Projection ( EPSG:4326 )); \n     var   zoomLevel   =   map . getZoom (); \n     bus . send ( ajax ,   { \n       url   :   guardar-centro?lon=   +   center . lon   +   lat=   +   center . lat   +   zoomLevel=   +   zoomLevel , \n       success   :   function ( indicators ,   textStatus ,   jqXHR )   { \n         alert ( centro guardado ); \n       }, \n       errorMsg   :   No se pudo guardar el centro \n     }); \n   });  });   Por \u00faltimo, deber\u00edamos poder instalar empaquetar nuestro plugin y reiniciar el portal para poder utilizar nuestro bot\u00f3n enlazado con nuestro servlet.", 
            "title": "Creando el servlet"
        }, 
        {
            "location": "/server/config_servlet/#manejando-errores", 
            "text": "El servlet anterior parte de la base de que las peticiones que se hagan van a ser satisfactorias, se va a guardar el centro. Pero en la realidad esto no es la norma general. \u00bfQu\u00e9 sucede si la petici\u00f3n no incluye los par\u00e1metros  lon ,  lat , o  zoomLevel ? \u00bfQu\u00e9 pasa si el fichero  portal.properties  ha sido eliminado?  El est\u00e1ndar HTML define una serie de c\u00f3digos que pueden ayudar en la comunicaci\u00f3n de estas condiciones excepcionales:   Ok (200) : Ejecuci\u00f3n satisfactoria.  Bad Request (400) : La petici\u00f3n no pudo ser entendida por el servidor. Aqu\u00ed se puede indicar que no fue especificado el par\u00e1metro. Es posible acompa\u00f1ar el c\u00f3digo con un mensaje descriptivo.  Internal server error (500) : Adecuado para indicar errores graves, irrecuperables, como un bug en el c\u00f3digo o que el fichero  portal.properties .   Para utilizar estos errores, basta con utilizar el m\u00e9todo  HttpServletResponse.sendError :  Por ejemplo, en caso de que se desee enviar un c\u00f3digo  Bad Request (400)  cuando el par\u00e1metro  lon  no est\u00e9 presente:  if   ( lon   ==   null )   { \n   resp . sendError ( HttpServletResponse . SC_BAD_REQUEST ); \n   return ;  }   Teniendo esto en cuenta, el servlet se podr\u00eda escribir as\u00ed:  package   org.fao.unredd ;  import   java.io.File ;  import   java.io.FileInputStream ;  import   java.io.FileOutputStream ;  import   java.io.IOException ;  import   java.io.InputStream ;  import   java.io.OutputStream ;  import   java.util.Properties ;  import   javax.servlet.ServletException ;  import   javax.servlet.http.HttpServlet ;  import   javax.servlet.http.HttpServletRequest ;  import   javax.servlet.http.HttpServletResponse ;  import   org.geoladris.Geoladris ;  import   org.geoladris.config.Config ;  public   class   GuardarCentroServlet   extends   HttpServlet   { \n\n   @Override \n   protected   void   doGet ( HttpServletRequest   req ,   HttpServletResponse   resp ) \n       throws   ServletException ,   IOException   { \n     Config   config   =   ( Config )   getServletContext (). getAttribute ( Geoladris . ATTR_CONFIG ); \n     File   propertiesFile   =   new   File ( config . getDir (),   portal.properties ); \n     Properties   properties   =   new   Properties (); \n     String   lon   =   req . getParameter ( lon ); \n     String   lat   =   req . getParameter ( lat ); \n     String   zoomLevel   =   req . getParameter ( zoomLevel ); \n\n     if   ( lon   ==   null   ||   lat   ==   null   ||   zoomLevel   ==   null )   { \n       resp . sendError ( HttpServletResponse . SC_BAD_REQUEST ,   Los par\u00e1metros lon, lat y zoomLevel son obligatorios. ); \n       return ; \n     } \n\n     // Lectura del fichero \n     try   { \n       FileInputStream   inputStream   =   new   FileInputStream ( propertiesFile ); \n       properties . load ( inputStream ); \n       inputStream . close (); \n     }   catch   ( IOException   e )   { \n       resp . sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ,   Error grave en el servidor. Contacte al administrador ); \n       return ; \n     } \n\n     properties . put ( map.centerLonLat ,   req . getParameter ( lon )   +   ,   +   req . getParameter ( lat )); \n     properties . put ( map.initialZoomLevel ,   req . getParameter ( zoomLevel )); \n\n     // Escritura del fichero \n     try   { \n       FileOutputStream   outputStream   =   new   FileOutputStream ( propertiesFile ); \n       properties . store ( outputStream ,   null ); \n       outputStream . close (); \n     }   catch   ( IOException   e )   { \n       resp . sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ,   Error grave en el servidor. Contacte al administrador ); \n       return ; \n     } \n   }  }", 
            "title": "Manejando errores"
        }, 
        {
            "location": "/server/db_servlet/", 
            "text": "Ahora vamos a crear un servlet que nos muestre una lista con las provincias de Argentina.\n\n\nCargando datos\n\n\nPara ello, primero deberemos cargar las provincias en la base de datos. Nos descargamos los \ndatos\n y los descomprimimos.\n\n\nLuego ejecutamos el comando para cargarlos en la base de datos:\n\n\npsql -h localhost -p \n65432\n -U admin -d nfms -f provincias.sql\n\n\n\n\n\ny comprobamos que se hayan cargado correctamente:\n\n\npsql -h localhost -p \n65432\n -U admin -d nfms -c \nSELECT COUNT(*) FROM provincias\n\n\n\n\n\n\nCreando el proyecto\n\n\nDe nuevo, creamos el proyecto  y la configuraci\u00f3n de nuestro servlet:\n\n\n$ mvn archetype:generate -DgroupId\n=\norg.fao.unredd -DartifactId\n=\nprovincias -DarchetypeArtifactId\n=\nmaven-archetype-quickstart -DinteractiveMode\n=\nfalse\n\n\n\n\n\n\ncon su configuraci\u00f3n en el fichero \npom.xml\n:\n\n\nproject\n \n...\n\n  ...\n  \ndependencies\n\n    ...\n    \ndependency\n\n        \ngroupId\njavax.servlet\n/groupId\n\n        \nartifactId\njavax.servlet-api\n/artifactId\n\n        \nversion\n3.0.1\n/version\n\n        \nscope\nprovided\n/scope\n\n    \n/dependency\n\n    \ndependency\n\n        \ngroupId\ncom.github.geoladris\n/groupId\n\n        \nartifactId\ncore\n/artifactId\n\n        \nversion\n7.0.0\n/version\n\n    \n/dependency\n\n  \n/dependencies\n\n\n/project\n\n\n\n\n\n\ny en el \nweb-fragment.xml\n:\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nweb-fragment\n \nversion=\n3.0\n \nxmlns=\nhttp://java.sun.com/xml/ns/javaee\n\n    \nxmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n    \nxsi:schemaLocation=\nhttp://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd\n\n  \nservlet\n\n    \nservlet-name\nprovincias-servlet\n/servlet-name\n\n    \nservlet-class\norg.fao.unredd.ProvinciasServlet\n/servlet-class\n\n  \n/servlet\n\n  \nservlet-mapping\n\n    \nservlet-name\nprovincias-servlet\n/servlet-name\n\n    \nurl-pattern\n/provincias\n/url-pattern\n\n  \n/servlet-mapping\n\n\n/web-fragment\n\n\n\n\n\n\nCreando el servlet\n\n\nEn este caso, nuestro servlet deber\u00e1 conectar a la base de datos del portal. Para ello, existen diferentes alternativas, unas mejores que otras en funci\u00f3n del contexto.\n\n\nConexi\u00f3n manual a base de datos en Java\n\n\nCuando queremos conectar a la base de datos desde un servicio Java tenemos que utilizar la API JDBC (Java DataBase Connectivity).\n\n\nEn general, el c\u00f3digo para conectar a una base de datos en Java es el siguiente:\n\n\nClass\n.\nforName\n(\norg.postgresql.Driver\n);\n\n\nConnection\n \nconnection\n \n=\n \nDriverManager\n.\ngetConnection\n(\n\n   \njdbc:postgresql://hostname:port/dbname\n,\nusername\n,\n \npassword\n);\n\n\n...\n\n\nconnection\n.\nclose\n();\n\n\n\n\n\n\n\n\nEn el c\u00f3digo anterior estamos conectando a una base de datos PostgreSQL, para lo cual instanciamos el driver \norg.postgresql.Driver\n y conectamos usando la URL propia de PostgreSQL \njdbc:postgresql://hostname:port\n. Estos dos aspectos cambiar\u00e1n en funci\u00f3n del tipo de base de datos a la que estemos conectando.\n\n\n\n\nPrimero, instanciamos el driver para que se autoregistre en el \nDriverManager\n y poder invocar despu\u00e9s el m\u00e9todo \ngetConnection\n para obtener la conexi\u00f3n. Por \u00faltimo, es necesario cerrar la conexi\u00f3n.\n\n\nPor medio del objeto de tipo \nConnection\n podremos obtener instancias de \nStatement\n, con las que se pueden enviar instrucciones SQL al servidor de base de datos.\n\n\nConexi\u00f3n configurada en el portal\n\n\nAunque ser\u00eda posible poner en el m\u00e9todo \ndoGet\n de nuestro servlet la creaci\u00f3n de la conexi\u00f3n, no es recomendable ya que es un proceso costoso y ralentizar\u00eda nuestra aplicaci\u00f3n.\n\n\nPara evitar crear una conexi\u00f3n cada vez, el portal trae configurada una conexi\u00f3n de forma que sea Tomcat (el servidor) el que gestione las conexiones por nosotros. Pero, \u00bfc\u00f3mo podemos obtener una de estas conexiones gestionadas por Tomcat?\n\n\nEl c\u00f3digo Java cambia ligeramente, ya que ahora se obtiene un objeto de tipo \njava.sql.DataSource\n que es el que nos proporciona las conexiones:\n\n\nInitialContext\n \ncontext\n;\n\n\nDataSource\n \ndataSource\n;\n\n\ntry\n \n{\n\n  \ncontext\n \n=\n \nnew\n \nInitialContext\n();\n\n  \ndataSource\n \n=\n \n(\nDataSource\n)\n \ncontext\n.\nlookup\n(\njava:/comp/env/jdbc/nfms\n);\n\n\n}\n \ncatch\n \n(\nNamingException\n \ne\n)\n \n{\n\n  \nthrow\n \nnew\n \nServletException\n(\nProblema en la configuraci\u00f3n\n);\n\n\n}\n\n\n\ntry\n \n{\n\n  \nConnection\n \nconnection\n \n=\n \ndataSource\n.\ngetConnection\n();\n\n  \n// ...\n\n  \nconnection\n.\nclose\n();\n\n\n}\n \ncatch\n \n(\nSQLException\n \ne\n)\n \n{\n\n  \nthrow\n \nnew\n \nServletException\n(\nNo se pudo obtener una conexi\u00f3n\n);\n\n\n}\n\n\n\ntry\n \n{\n\n  \ncontext\n.\nclose\n();\n\n\n}\n \ncatch\n \n(\nNamingException\n \ne\n)\n \n{\n\n  \n// ignore\n\n\n}\n\n\n\n\n\n\nSi sutitu\u00edmos la l\u00ednea que contiene los puntos suspensivos por c\u00f3digo que haga algo m\u00e1s interesante con la conexi\u00f3n, podemos devolver un JSON con el array de provincias que hay en la tabla que hemos cargado:\n\n\npackage\n \norg.fao.unredd\n;\n\n\n\nimport\n \njava.io.IOException\n;\n\n\nimport\n \njava.sql.Connection\n;\n\n\nimport\n \njava.sql.ResultSet\n;\n\n\nimport\n \njava.sql.SQLException\n;\n\n\nimport\n \njava.sql.Statement\n;\n\n\nimport\n \njava.util.ArrayList\n;\n\n\n\nimport\n \njavax.naming.InitialContext\n;\n\n\nimport\n \njavax.naming.NamingException\n;\n\n\nimport\n \njavax.servlet.ServletException\n;\n\n\nimport\n \njavax.servlet.http.HttpServlet\n;\n\n\nimport\n \njavax.servlet.http.HttpServletRequest\n;\n\n\nimport\n \njavax.servlet.http.HttpServletResponse\n;\n\n\nimport\n \njavax.sql.DataSource\n;\n\n\n\nimport\n \nnet.sf.json.JSONSerializer\n;\n\n\n\npublic\n \nclass\n \nProvinciasDBServlet\n \nextends\n \nHttpServlet\n \n{\n\n\nprivate\n \nstatic\n \nfinal\n \nlong\n \nserialVersionUID\n \n=\n \n1L\n;\n\n\n  \n@Override\n\n  \nprotected\n \nvoid\n \ndoGet\n(\nHttpServletRequest\n \nreq\n,\n \nHttpServletResponse\n \nresp\n)\n\n      \nthrows\n \nServletException\n,\n \nIOException\n \n{\n\n    \nInitialContext\n \ncontext\n;\n\n    \nDataSource\n \ndataSource\n;\n\n    \ntry\n \n{\n\n      \ncontext\n \n=\n \nnew\n \nInitialContext\n();\n\n      \ndataSource\n \n=\n \n(\nDataSource\n)\n \ncontext\n.\nlookup\n(\njava:/comp/env/jdbc/nfms\n);\n\n    \n}\n \ncatch\n \n(\nNamingException\n \ne\n)\n \n{\n\n      \nthrow\n \nnew\n \nServletException\n(\nProblema en la configuraci\u00f3n\n);\n\n    \n}\n\n\n    \nList\nString\n \nprovincias\n \n=\n \nnew\n \nArrayList\nString\n();\n\n    \ntry\n \n{\n\n      \nConnection\n \nconnection\n \n=\n \ndataSource\n.\ngetConnection\n();\n\n      \nStatement\n \nstatement\n \n=\n \nconnection\n.\ncreateStatement\n();\n\n      \nResultSet\n \nresult\n \n=\n \nstatement\n.\nexecuteQuery\n(\nSELECT fna FROM provincias\n);\n\n      \nwhile\n \n(\nresult\n.\nnext\n())\n \n{\n\n        \nprovincias\n.\nadd\n(\nresult\n.\ngetString\n(\nname_1\n));\n\n      \n}\n\n\n      \nresp\n.\nsetContentType\n(\napplication/json\n);\n\n      \nJSONSerializer\n.\ntoJSON\n(\nprovincias\n).\nwrite\n(\nresp\n.\ngetWriter\n());\n\n\n      \nconnection\n.\nclose\n();\n\n    \n}\n \ncatch\n \n(\nSQLException\n \ne\n)\n \n{\n\n      \nthrow\n \nnew\n \nServletException\n(\nNo se pudo obtener una conexi\u00f3n\n,\n \ne\n);\n\n    \n}\n\n\n    \ntry\n \n{\n\n      \ncontext\n.\nclose\n();\n\n    \n}\n \ncatch\n \n(\nNamingException\n \ne\n)\n \n{\n\n      \nthrow\n \nnew\n \nServletException\n(\nNo se pudo liberar el recurso\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nAhora, para probarlo tendremos que crear un plugin cliente con una lista que al cargar llame al servlet que acabamos de crear y rellene la lista con los nombres devueltos. Bastar\u00e1 crear un nuevo plugin con el siguiente m\u00f3dulo (para m\u00e1s detalles ver apartados sobre \ncliente\n):\n\n\ndefine\n([\n \nmessage-bus\n \n],\n \nfunction\n(\nbus\n)\n \n{\n\n  \nvar\n \nlist\n \n=\n \ndocument\n.\ncreateElement\n(\ndiv\n);\n\n  \nlist\n.\nid\n \n=\n \nlista_provincias\n;\n\n  \ndocument\n.\nbody\n.\nappendChild\n(\nlist\n);\n\n  \nbus\n.\nsend\n(\najax\n,\n \n{\n\n    \nurl\n \n:\n \nprovincias\n,\n\n    \nsuccess\n \n:\n \nfunction\n(\njson\n,\n \ntextStatus\n,\n \njqXHR\n)\n \n{\n\n      \nvar\n \nprovincias\n \n=\n \nJSON\n.\nparse\n(\njson\n);\n\n      \nfor\n \n(\nvar\n \ni\n \n=\n \n0\n;\n \ni\n \n \nprovincias\n.\nlength\n;\n \ni\n++\n)\n \n{\n\n        \nvar\n \ndiv\n \n=\n \ndocument\n.\ncreateElement\n(\ndiv\n);\n\n        \ndiv\n.\ninnerHTML\n \n=\n \nprovincias\n[\ni\n];\n\n        \ndiv\n.\nclassName\n \n=\n \nprovincia\n;\n\n        \nlist\n.\nappendChild\n(\ndiv\n);\n\n      \n}\n\n    \n},\n\n    \nerrorMsg\n \n:\n \nNo se pudo obtener la lista de provincias\n\n  \n});\n\n\n});\n\n\n\n\n\n\ny los siguientes estilos:\n\n\ndiv\n#\nlista_provincias\n \n{\n\n    \nposition\n:\n \nfixed\n;\n\n    \nbottom\n:\n \n25\n;\n\n    \npadding\n:\n \n10\npx\n;\n\n    \nleft\n:\n \n0\n;\n\n    \nz-index\n:\n \n999\n;\n\n    \nbackground\n:\n \nwhite\n;\n\n    \nmax-height\n:\n \n200\npx\n;\n\n    \noverflow-y\n:\n \nauto\n;\n\n\n}\n\n\n\ndiv\n#\nlista_provincias\ndiv\n \n{\n\n    \npadding\n:\n \n10\npx\n;\n\n\n}\n\n\n\n\n\n\nPor \u00faltimo, deber\u00edamos poder instalar nuestro plugin, empaquetar la aplicaci\u00f3n y reiniciar el portal para poder utilizar nuestro bot\u00f3n enlazado con nuestro servlet.", 
            "title": "Servlet de acceso a base de datos"
        }, 
        {
            "location": "/server/db_servlet/#cargando-datos", 
            "text": "Para ello, primero deberemos cargar las provincias en la base de datos. Nos descargamos los  datos  y los descomprimimos.  Luego ejecutamos el comando para cargarlos en la base de datos:  psql -h localhost -p  65432  -U admin -d nfms -f provincias.sql  y comprobamos que se hayan cargado correctamente:  psql -h localhost -p  65432  -U admin -d nfms -c  SELECT COUNT(*) FROM provincias", 
            "title": "Cargando datos"
        }, 
        {
            "location": "/server/db_servlet/#creando-el-proyecto", 
            "text": "De nuevo, creamos el proyecto  y la configuraci\u00f3n de nuestro servlet:  $ mvn archetype:generate -DgroupId = org.fao.unredd -DartifactId = provincias -DarchetypeArtifactId = maven-archetype-quickstart -DinteractiveMode = false   con su configuraci\u00f3n en el fichero  pom.xml :  project   ... \n  ...\n   dependencies \n    ...\n     dependency \n         groupId javax.servlet /groupId \n         artifactId javax.servlet-api /artifactId \n         version 3.0.1 /version \n         scope provided /scope \n     /dependency \n     dependency \n         groupId com.github.geoladris /groupId \n         artifactId core /artifactId \n         version 7.0.0 /version \n     /dependency \n   /dependencies  /project   y en el  web-fragment.xml :  ?xml version= 1.0  encoding= UTF-8 ?  web-fragment   version= 3.0   xmlns= http://java.sun.com/xml/ns/javaee \n     xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n     xsi:schemaLocation= http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd \n   servlet \n     servlet-name provincias-servlet /servlet-name \n     servlet-class org.fao.unredd.ProvinciasServlet /servlet-class \n   /servlet \n   servlet-mapping \n     servlet-name provincias-servlet /servlet-name \n     url-pattern /provincias /url-pattern \n   /servlet-mapping  /web-fragment", 
            "title": "Creando el proyecto"
        }, 
        {
            "location": "/server/db_servlet/#creando-el-servlet", 
            "text": "En este caso, nuestro servlet deber\u00e1 conectar a la base de datos del portal. Para ello, existen diferentes alternativas, unas mejores que otras en funci\u00f3n del contexto.", 
            "title": "Creando el servlet"
        }, 
        {
            "location": "/server/db_servlet/#conexion-manual-a-base-de-datos-en-java", 
            "text": "Cuando queremos conectar a la base de datos desde un servicio Java tenemos que utilizar la API JDBC (Java DataBase Connectivity).  En general, el c\u00f3digo para conectar a una base de datos en Java es el siguiente:  Class . forName ( org.postgresql.Driver );  Connection   connection   =   DriverManager . getConnection ( \n    jdbc:postgresql://hostname:port/dbname , username ,   password );  ...  connection . close ();    En el c\u00f3digo anterior estamos conectando a una base de datos PostgreSQL, para lo cual instanciamos el driver  org.postgresql.Driver  y conectamos usando la URL propia de PostgreSQL  jdbc:postgresql://hostname:port . Estos dos aspectos cambiar\u00e1n en funci\u00f3n del tipo de base de datos a la que estemos conectando.   Primero, instanciamos el driver para que se autoregistre en el  DriverManager  y poder invocar despu\u00e9s el m\u00e9todo  getConnection  para obtener la conexi\u00f3n. Por \u00faltimo, es necesario cerrar la conexi\u00f3n.  Por medio del objeto de tipo  Connection  podremos obtener instancias de  Statement , con las que se pueden enviar instrucciones SQL al servidor de base de datos.", 
            "title": "Conexi\u00f3n manual a base de datos en Java"
        }, 
        {
            "location": "/server/db_servlet/#conexion-configurada-en-el-portal", 
            "text": "Aunque ser\u00eda posible poner en el m\u00e9todo  doGet  de nuestro servlet la creaci\u00f3n de la conexi\u00f3n, no es recomendable ya que es un proceso costoso y ralentizar\u00eda nuestra aplicaci\u00f3n.  Para evitar crear una conexi\u00f3n cada vez, el portal trae configurada una conexi\u00f3n de forma que sea Tomcat (el servidor) el que gestione las conexiones por nosotros. Pero, \u00bfc\u00f3mo podemos obtener una de estas conexiones gestionadas por Tomcat?  El c\u00f3digo Java cambia ligeramente, ya que ahora se obtiene un objeto de tipo  java.sql.DataSource  que es el que nos proporciona las conexiones:  InitialContext   context ;  DataSource   dataSource ;  try   { \n   context   =   new   InitialContext (); \n   dataSource   =   ( DataSource )   context . lookup ( java:/comp/env/jdbc/nfms );  }   catch   ( NamingException   e )   { \n   throw   new   ServletException ( Problema en la configuraci\u00f3n );  }  try   { \n   Connection   connection   =   dataSource . getConnection (); \n   // ... \n   connection . close ();  }   catch   ( SQLException   e )   { \n   throw   new   ServletException ( No se pudo obtener una conexi\u00f3n );  }  try   { \n   context . close ();  }   catch   ( NamingException   e )   { \n   // ignore  }   Si sutitu\u00edmos la l\u00ednea que contiene los puntos suspensivos por c\u00f3digo que haga algo m\u00e1s interesante con la conexi\u00f3n, podemos devolver un JSON con el array de provincias que hay en la tabla que hemos cargado:  package   org.fao.unredd ;  import   java.io.IOException ;  import   java.sql.Connection ;  import   java.sql.ResultSet ;  import   java.sql.SQLException ;  import   java.sql.Statement ;  import   java.util.ArrayList ;  import   javax.naming.InitialContext ;  import   javax.naming.NamingException ;  import   javax.servlet.ServletException ;  import   javax.servlet.http.HttpServlet ;  import   javax.servlet.http.HttpServletRequest ;  import   javax.servlet.http.HttpServletResponse ;  import   javax.sql.DataSource ;  import   net.sf.json.JSONSerializer ;  public   class   ProvinciasDBServlet   extends   HttpServlet   {  private   static   final   long   serialVersionUID   =   1L ; \n\n   @Override \n   protected   void   doGet ( HttpServletRequest   req ,   HttpServletResponse   resp ) \n       throws   ServletException ,   IOException   { \n     InitialContext   context ; \n     DataSource   dataSource ; \n     try   { \n       context   =   new   InitialContext (); \n       dataSource   =   ( DataSource )   context . lookup ( java:/comp/env/jdbc/nfms ); \n     }   catch   ( NamingException   e )   { \n       throw   new   ServletException ( Problema en la configuraci\u00f3n ); \n     } \n\n     List String   provincias   =   new   ArrayList String (); \n     try   { \n       Connection   connection   =   dataSource . getConnection (); \n       Statement   statement   =   connection . createStatement (); \n       ResultSet   result   =   statement . executeQuery ( SELECT fna FROM provincias ); \n       while   ( result . next ())   { \n         provincias . add ( result . getString ( name_1 )); \n       } \n\n       resp . setContentType ( application/json ); \n       JSONSerializer . toJSON ( provincias ). write ( resp . getWriter ()); \n\n       connection . close (); \n     }   catch   ( SQLException   e )   { \n       throw   new   ServletException ( No se pudo obtener una conexi\u00f3n ,   e ); \n     } \n\n     try   { \n       context . close (); \n     }   catch   ( NamingException   e )   { \n       throw   new   ServletException ( No se pudo liberar el recurso ); \n     } \n   }  }   Ahora, para probarlo tendremos que crear un plugin cliente con una lista que al cargar llame al servlet que acabamos de crear y rellene la lista con los nombres devueltos. Bastar\u00e1 crear un nuevo plugin con el siguiente m\u00f3dulo (para m\u00e1s detalles ver apartados sobre  cliente ):  define ([   message-bus   ],   function ( bus )   { \n   var   list   =   document . createElement ( div ); \n   list . id   =   lista_provincias ; \n   document . body . appendChild ( list ); \n   bus . send ( ajax ,   { \n     url   :   provincias , \n     success   :   function ( json ,   textStatus ,   jqXHR )   { \n       var   provincias   =   JSON . parse ( json ); \n       for   ( var   i   =   0 ;   i     provincias . length ;   i ++ )   { \n         var   div   =   document . createElement ( div ); \n         div . innerHTML   =   provincias [ i ]; \n         div . className   =   provincia ; \n         list . appendChild ( div ); \n       } \n     }, \n     errorMsg   :   No se pudo obtener la lista de provincias \n   });  });   y los siguientes estilos:  div # lista_provincias   { \n     position :   fixed ; \n     bottom :   25 ; \n     padding :   10 px ; \n     left :   0 ; \n     z-index :   999 ; \n     background :   white ; \n     max-height :   200 px ; \n     overflow-y :   auto ;  }  div # lista_provincias div   { \n     padding :   10 px ;  }   Por \u00faltimo, deber\u00edamos poder instalar nuestro plugin, empaquetar la aplicaci\u00f3n y reiniciar el portal para poder utilizar nuestro bot\u00f3n enlazado con nuestro servlet.", 
            "title": "Conexi\u00f3n configurada en el portal"
        }, 
        {
            "location": "/server/deploy_considerations/", 
            "text": "A lo largo del curso hemos incluido nuestros plugins copiando los paquetes \n.jar\n (generados con \nmvn package\n) en el directorio \nWEB-INF/lib\n dentro de nuestra aplicaci\u00f3n.\n\n\nEsta aproximaci\u00f3n (que es la misma que gasta GeoServer para instalar extensiones) funciona bien siempre y cuando no sobreescribamos nuestro fichero \n.war\n en el directorio \nwebapps\n de Tomcat.\n\n\n\n\nNOTA\n: En este curso el directorio \nwebapps\n est\u00e1 dentro de un contenedor de Docker y no tenemos acceso a \u00e9l, por lo que no tenemos que preocuparnos de esto.\n\n\n\n\nSin embargo, en el momento que sobreescribamos el fichero (por ejemplo, porque queremos desplegar una nueva versi\u00f3n), el directorio \nWEB-INF/lib\n se volver\u00e1 a generar y perderemos los plugins que hayamos copiado en dicho directorio.\n\n\nPara evitar esto lo que podemos hacer es incluir nuestros plugins en un nuevo fichero \n.war\n. As\u00ed, en lugar de gastar el fichero \ndemo-*.war\n que proporciona Geoladris, podemos utilizar el \nscript\n de generaci\u00f3n de aplicaciones. Para ello, en primer lugar tendremos que instalar nuestro plugin en el repositorio local de Maven:\n\n\nmvn install\n\n\n\n\n\ny, posteriormente, incluir nuestro plugin en el fichero \nbuild.json\n:\n\n\n{\n\n    \n...\n\n    \nplugins\n:\n \n[\n\n        \n...\n\n        \norg.fao.unredd:hola-mundo:1.0-SNAPSHOT\n\n    \n]\n\n\n}\n\n\n\n\n\n\ny empaquetar la aplicaci\u00f3n:\n\n\ngeoladris_build.sh", 
            "title": "Consideraciones sobre el despliegue"
        }, 
        {
            "location": "/exercises/", 
            "text": "En este apartado se proponen varios ejercicios con sus soluciones para practicar y ampliar los contenidos del curso:\n\n\n\n\n\n\nA\u00f1ade un bot\u00f3n que a\u00f1ada un nuevo grupo de capas con una capa WMS al mapa. Puede usar el servicio WMS \nhttp://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r-t.cgi\n y la capa \nnexrad-n0r-wmst\n.\n\n\nSoluci\u00f3n\n: \njs\n, \ncss\n.\n\n\n\n\n\n\nA\u00f1ade un control con dos casillas para introducir latitud/longitud y un bot\u00f3n para hacer zoom a la coordenada especificada.\n\n\nSoluci\u00f3n\n: \njs\n, \ncss\n.\n\n\n\n\n\n\nA\u00f1ade una lista con nombres de pa\u00edses que cuando se pulsen hagan zoom al pa\u00eds seleccionado. Puedes utilizar los siguiente pa\u00edses y coordenadas:\n\n\n\n\nArgentina: [ -62, -38 ].\n\n\nBolivia: [ -65, -19 ].\n\n\nEcuador: [ -78, 0 ].\n\n\nParaguay: [ -57, -25 ].\n\n\n\n\nSoluci\u00f3n\n: \njs\n, \ncss\n.\n\n\n\n\n\n\nA\u00f1ade un control que muestre la escala del mapa. El control que hace esto es \nOpenLayers.Control.Scale\n.\n\n\nSoluci\u00f3n\n: \njs\n, \ncss\n.\n\n\n\n\n\n\nA\u00f1ade un bot\u00f3n que active un control del mapa de forma que cuando se pulse en el mapa se obtenga la temperatura en el punto. Para ello puedes utilizar el servicio de Open Weather Map con la siguiente URL: \nhttp://api.openweathermap.org/data/2.5/weather?APPID=d8cbabebfd28985fe4ca7ab08784de01\nlat=\nlatitud\nlon=\nlongitud\n.\n\n\nSoluci\u00f3n\n: \njs\n, \ncss\n.\n\n\n\n\n\n\nA\u00f1ade un bot\u00f3n que active un control del mapa para realizar medidas. El control que hace esto es \nOpenLayers.Control.Measure\n. Al finalizar la medida basta con mostrar una alerta (\nwindow.alert\n) con la medida realizada.\n\n\nSoluci\u00f3n\n: \njs\n.\n\n\n\n\n\n\nA\u00f1ade un control donde se pueda elegir la capa, el atributo de la tabla, el operador (\n==\n, \n!=\n, \n \n, \n=\n \n=\n, \n~\n) y un valor a introducir por el usuario, y al pulsar un bot\u00f3n se muestre una tabla con las filas que cumplan la condici\u00f3n (atributo - operador - valor).\n\n\nSoluci\u00f3n\n: \njs\n, \ncss\n.\n\n\n\n\n\n\nA\u00f1ade un control donde se pueda introducir un \nfiltro CQL\n manualmente y al pulsar un bot\u00f3n filtre una capa (configurada en el \npublic-conf.json\n).\n\n\nSoluci\u00f3n\n: \njs\n, \ncss\n.", 
            "title": "Ejercicios"
        }
    ]
}